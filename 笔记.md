# jsx语法中让回调函数内部this正确访问类实例的方法

1. 类组件中，自定义函数内部this绑定组件实例的方式：

   1. bind修改类函数this：constructor中：`this.fn = fn.bind(this)`

   2. 使用class field特性：

      constructor之外定义的变量和方法和constructor中`this.`定义的变量和方法完全一样，只是constructor中`this.`的定义会对其进行覆盖；我们在constructor之外定义一个箭头函数，然后这个箭头函数里面的this就是类实例，我们绑定事件时直接使用这个箭头函数

      （这个原理暂时不是很懂）

   3. 绑定一个箭头函数，箭头函数的函数体内容就是调用类方法

      ~~~jsx
      <button onclick={() => this.fn() }>按钮</button>
      ~~~

      原理就是我们`{}`里面的是一个箭头函数，首先我们在jsx模板中是可以通过this访问class实例的，可以理解为jsx中的`{}`就是一个函数作用域，这个函数属于我们的类实例对象，就比如

      ~~~JS
      let obj = {
          name: "jrd",
          fn() {
              // jsx语法中的{}就类似于这里，obj就相当于组件类实例。我们在这里可以通过this访问obj，类似于jsx的{}中可以通过this访问类实例对象
          }
      }
      ~~~

      然后上面`onclick={() => this.fn() }`就类似于我们在`fn`中创建了一个箭头函数，这个箭头函数的父级作用域就是`fn`的函数作用域，`fn`属于`obj`，自然这个箭头函数中的this就是obj，类比到jsx中，说明this就是类实例，既然`this.fn()`中this是类实例，所以`fn`的调用方式就是被`this`调用，所以`fn`内部的this就都指向了`this`，也就是类实例

   

   不进行处理类方法中的this绑定不到类实例的原因：

   ~~~jsx
   <button onclick={this.fn}>按钮</button>
   ~~~

   这里相当于一个函数体赋值，我们只是把this.fn的函数体赋值给了一个内部变量，在触发onclick事件的时候，其实是对{}内的函数进行独立调用（直接调用），所以我们相当于直接执行`fn`，并没有执行`this.fn`，这就导致fn是没有`this`的，而是属于window的，所以fn函数体里的this都无法正常访问类实例的属性

# 函数传参

~~~jsx
class App extends React.Component {
    constructor() {
        super();
        this.state = {
            massage: "hello world"
        }
    }
    
    btnClick(event, name, age) {
        console.log("...")
    }
    
    reder() {
        const { message } = this.state;
        return (
        	<div>
                {/* 直接箭头函数接收event事件对象，然后函数体内给回调函数传参即可 */}
            	<button onclick={(event) => this.btnClick(event, "why", 18)}>按钮</button>
            </div>
        )
    }
}
~~~

