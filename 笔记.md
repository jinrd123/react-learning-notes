# jsx语法中让回调函数内部this正确访问类实例的方法

1. 类组件中，自定义函数内部this绑定组件实例的方式：

   1. bind修改类函数this：constructor中：`this.fn = fn.bind(this)`

   2. 使用class field特性：

      constructor之外定义的变量和方法和constructor中`this.`定义的变量和方法完全一样，只是constructor中`this.`的定义会对其进行覆盖；我们在constructor之外定义一个箭头函数，然后这个箭头函数里面的this就是类实例，我们绑定事件时直接使用这个箭头函数

      （这个原理暂时不是很懂）

   3. 绑定一个箭头函数，箭头函数的函数体内容就是调用类方法

      ~~~jsx
      <button onclick={() => this.fn() }>按钮</button>
      ~~~

      原理就是我们`{}`里面的是一个箭头函数，首先我们在jsx模板中是可以通过this访问class实例的，可以理解为jsx中的`{}`就是一个函数作用域，这个函数属于我们的类实例对象，就比如

      ~~~JS
      let obj = {
          name: "jrd",
          fn() {
              // jsx语法中的{}就类似于这里，obj就相当于组件类实例。我们在这里可以通过this访问obj，类似于jsx的{}中可以通过this访问类实例对象
          }
      }
      ~~~

      然后上面`onclick={() => this.fn() }`就类似于我们在`fn`中创建了一个箭头函数，这个箭头函数的父级作用域就是`fn`的函数作用域，`fn`属于`obj`，自然这个箭头函数中的this就是obj，类比到jsx中，说明this就是类实例，既然`this.fn()`中this是类实例，所以`fn`的调用方式就是被`this`调用，所以`fn`内部的this就都指向了`this`，也就是类实例

   

   不进行处理类方法中的this绑定不到类实例的原因：

   ~~~jsx
   <button onclick={this.fn}>按钮</button>
   ~~~

   这里相当于一个函数体赋值，我们只是把this.fn的函数体赋值给了一个内部变量，在触发onclick事件的时候，其实是对{}内的函数进行独立调用（直接调用），所以我们相当于直接执行`fn`，并没有执行`this.fn`，这就导致fn是没有`this`的，而是属于window的，所以fn函数体里的this都无法正常访问类实例的属性

# 函数传参

~~~jsx
class App extends React.Component {
    constructor() {
        super();
        this.state = {
            massage: "hello world"
        }
    }
    
    btnClick(event, name, age) {
        console.log("...")
    }
    
    reder() {
        const { message } = this.state;
        return (
        	<div>
                {/* 直接箭头函数接收event事件对象，然后函数体内给回调函数传参即可 */}
            	<button onclick={(event) => this.btnClick(event, "why", 18)}>按钮</button>
            </div>
        )
    }
}
~~~

# 创建脚手架项目

`npm install create-react-app -g`：全局安装react脚手架

`create-react-app demo`：创建名为demo的项目

`npm run start`：跑起来当前项目

# 组件通信

## 1.父传子props

父组件直接把数据在子组件标签中传给子组件；子组件的`contructor`函数接收一个`props`参数，然后调用`super(props)`。

子组件经过上述操作，就可以通过`this.props.父组件传来的数据`的方式获取到父组件传来的数据

父组件：

~~~jsx
<Child banner={banners}/>
~~~

子组件：

~~~jsx
export class AddCounter extends Component {
	constructor(props) {
        super(props)
    }
    
    render() {
        const { banners } = this.props
        return (
        	{/* 使用数据banners */}
        )
    }
}
~~~

## 2.子传父

父组件内部有操作组件内数据的方法，然后直接给子组件传递一个“包装函数”，即对自身方法的包装，函数体内是对自身方法的调用。**且这个函数是一个箭头函数。**

概况来说：父组件传给子组件的箭头函数就是为了调用真正修改数据的函数

子组件的某些事件触发子组件内的某个回调函数，回调函数的逻辑就是通过`this.props.父组件传来的方法`去调用父组件传递的箭头函数。

父组件：

~~~jsx
class App extends React.Component {
    constructor() {
        super();
        this.state = {
            counter: 0,
        }
    }

    changeCounter(counter) {
        this.setState({ counter: this.state.counter + counter })
    }	
    
    render() {
        const { counter } = this.state;
        return (
            <div>
                <h2>当前计数：{counter}</h2>
                <AddCounter addClick={(count) => this.changeCounter(count) }/>
            </div>
        )
    }
}

export default App;
~~~

子组件：

~~~jsx
export class AddCounter extends Component {
    addCount(count) {
        /*
        	因为addClick是父组件中传来的箭头函数，所以addClick函数体中的this一直都指向的是父组件实例，不会因为这里的调用方式而改变
        */
        this.props.addClick(count);
    }
    
    render(
    	<div>
    		<button onclick={() => this.addCount(1)}>+1</button>
        	<button onclick={() => this.addCount(2)}>+2</button>
        	<button onclick={() => this.addCount(5)}>+5</button>
    	</div>
    )
}
~~~

## 3.借助`React.createContext()`

1. 建立一个上下文对象

~~~js
import React from "react";

const ThemeContext = React.createContext();

export default ThemeContext
~~~

2. 通过上下文对象标签（ThemeContext上下文对应的上下文标签：<ThemeContext.Provider>）的的`value`属性给上下文标签内部的子组件传递数据

~~~jsx
<ThemeContext.Provider value={{color: "red", size: "30"}}>
    <Home></Home>
</ThemeContext.Provider>
~~~

3. 上下文标签内部的子组件（**后代组件**）需要绑定上下文（上面2相当于上下文提供了数据，但组件还没接收），然后才能使用上下文数据

Home组件的子组件HomeInfo组件：

~~~jsx
export class HomeInfo extends Component {
    reder() {
        return (
            {/* 组件内部直接使用上下文标签的value属性提供的数据 */}
        	<div>{this.context.red}</div>
        )
    }
}

//组件暴露前绑定上下文
HomeInfo.contextType = ThemeContext

export default HomeInfo
~~~

函数式组件中获取上下文提供的数据：

我们在想使用数据的地方使用上下文对应的<ThemeContext.Consumer>标签，标签内部的{}内是一个函数，这个函数接收的第一个参数就是<ThemeContext.Provider>的value属性，通过value属性自然就可以拿到数据了

~~~jsx
import ThemeContext from "..."

function HomeBanner() {
    return <div>
    	<ThemeContext.Consumer>
        	{
                value => {
                    return <h2>{ value.color }</h2>
                }
            }
        </ThemeContext.Consumer>
    </div>
}
~~~

当然<ThemeContext.Consumer>不只是在函数组件中使用，如果一个自定义组件在很多个嵌套的上下文标签内部，绑定上下文对象只能绑定一个，所以他如果想获得多个上下文的数据，可以使用<ThemeContext.Consumer>，与绑定的那个上下文`this.context`不冲突。

# 组件的生命周期

常用：

* constructor
* render
* componentDidMount
* componentDidUpdate
* componentWillUnmount

# 类型验证

* propTypes
* defaultProps

# react实现插槽效果

## this.props.children

父组件中直接往子组件的中间放dom元素，放在自定义组件中间的dom元素会按顺序出现在子组件的`props.children`数组中，这里所说的dom是指jsx中的dom，自然子组件中通过`this.props.children[index]`访问到的自然是jsx语法下的dom元素，这个元素直接可以在子组件的jsx模板中使用。

父组件：

~~~jsx
render() {
    return (
        <div>
            <NavBar>
                <button>按钮</button>
                <h2>标题</h2>
                <i>斜体文字</i>
            </NavBar>
        </div>
	)
}
~~~

子组件：

~~~jsx
render() {
    const { children } = this.props;
    return (
        <div>
            <div className="left">{children[0]}</div>
            <div className="center">{children[1]}</div>
            <div className="right">{children[2]}</div>
        </div>
    )
}
~~~

plus：如果父组件中，子组件的中间只传递了一个dom标签，那么子组件内部`this.props.children`就是这个dom，而不是一个数组。

## this.props（推荐）

在父组件中我们直接给子组件标签传递属性，但是我们传递的属性值就是jsx的dom元素，所以我们在子组件中通过`this.props`解构赋值就可以拿到父组件传来的dom元素，而不用借助`children`属性

子组件：

~~~jsx
render() {
    const { leftSlot, centerSlot, rightSlot } = this.props;
    return (
        <div>
            <div className="left">{leftSlot}</div>
            <div className="center">{centerSlot}</div>
            <div className="right">{rightSlot}</div>
        </div>
    )
}
~~~

父组件：

~~~jsx
render() {
    return (
        <div>
            <NavBar
            	leftSlot={<button>按钮</button>}
                centerSlot={<h2>标题</h2>}
                rightSlot={<i>斜体文字</i>}
            />
        </div>
	)
}
~~~

## 作用域插槽

概念：我们父组件决定子组件使用什么dom结构（标签），数据仍然是子组件自身的。

实现：父组件直接传给子组件一个返回dom结构的函数，子组件自己去调用这个函数并传入自身的数据来生成最终的jsxDOM即可

父组件：

~~~jsx
render() {
    return (
        <div>
            <NavBar
            	itemType={(item) => <button>{item}</button>}
            />
        </div>
	)
}
~~~

子组件：

~~~jsx
render() {
    const { itemType } = this.props;
    return (
        <div>
            {itemType(子组件本身的数据)}
        </div>
    )
}
~~~





# CSS方案

## css in js（终极方案）

借助styled-components库

`npm install styled-components`

vscode插件：vscode-styled-components（css代码语法高亮）



---

Plus标签模版字符串的使用：

~~~typescript
function foo(...args) {
  console.log(args);
}

foo("why", 18, 1.88); // 普通调用
foo`my name is ${name}, age is ${age}` // 标签模版字符串调用函数： 函数`paramsStr`
~~~

标签模版字符串的输出：

~~~js
[
  ['my name is', 'age is', ''],
  "why",
  18
]
~~~

也就是说，如果用``给某个函数传参的话，会把模版字符串的内容以${}进行分割，第一个参数是一个数组，数组里的项就是${}分割之后的子字符串，剩下的第二第三...等参数就依次是${}进行变量替换后的结果

---



styled-components基本使用：

`style.js`：

~~~js
import styled from "styled-components";

export const AppWrapper = styled.div`
	.section {
		border: 1px solid red;
		
		.title {
			font-size: 30px;
			
			&:hover {
				background-color: purple;
			}
		}
	}
	
	.footer {
		border: 1px solid orange;
	}
`
~~~

原理上来讲就是styled-components提供的styled对象里面有很多方法，div就是其中的一个方法，这个方法最终返回一个组件（div函数根据``接收的参数给它的子类添加样式，具体咋实现的那就是styled-components完成的事情了），我们就是拿着这个组件去用就行了

`App.jsx`：

~~~jsx
import React, { PureComponent } from 'react';
import { AppWrapper } from "./style";

export class App extends PureComponent {
  render() {
    return (
    	<AppWrapper>
      	<div className='section'>
        	<h2 className='title'>我是标题</h2>
        </div>
        <div className='footer'>
        	<p>hhh</p>
        </div>
      </AppWrapper>
    )
  }
}

export default App
~~~

<AppWrapper>相当于我们用styled.div方法创建出来的div标签，这个组件与div的不同之处就在于这个组件会给它的子元素添加样式。

# React性能优化

我们在`extends Component`的类组件中，只要是调用`this.setState`就会触发`render`函数的执行，包括里面所有的自组件默认情况下都会重新渲染，为了减少无效render（数据没变）的频率，我们需要在`shouldComponentUpdate(nextProps, newState)`生命周期中进行逻辑判断是否state或者props发生改变，对应返回true或false（是否渲染）。为了避免这种繁琐的逻辑判断：

只需要让类组件继承PureComponent：组件会自动进行判断state或者props是否发生改变，改变则调用render

我们希望函数组件也能根据props是否改变来决定是否重新渲染，就需要用到react提供的memo方法：

~~~js
import { memo } from "react";

const Profile = memo(函数组件函数); // memo接收原来的函数组件，返回一个组件，这个组件就有自动判断是否render的功能

export default Profile;
~~~



# React Hooks

作用：在不使用类组件的前提下，让函数组件中使用state以及react生命周期等特性

## useState

函数组件结合hook（useState）实现计数器组件：

~~~jsx
import React, { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);
  
  return (
  	<div>
    	<h2>当前计数：{count}</h2>
      <button onClick={e => setCount(count + 1)}>+1</button>
      <button onClick={e => setCount(count - 1)}>-1</button>
    </div>
  )
}
~~~

只能在函数的最外层调用hook（不能放在if中等子作用域）

useState的实现原理：usestate会在一个函数组件外部（反正不随函数组件的执行完毕而销毁）定义一个state变量，这其实就等价于class组件中的this.state，实现函数组件state状态保留的效果。

（useState这种函数就是一个hook）

## useEffect

对于函数组件来说，把类似于网络请求、DOM操作（比如如下的修改document.title）、事件监听等逻辑放到函数体的最上层是不合理的，这些事情都是组件渲染带来的副作用，这也就是useEffect的意思：把渲染组件伴随的副作用逻辑放到useEffect的回调函数中

实现计数器数值改变时修改document.title：

~~~jsx
import React, {memo} from "react";
import { useState, useEffect } from "react";

const App = memo(() => {
  const [count, setCount] = useState(200);
  
  useEffect(() => { // 当前回调函数会在组件被渲染完成后自动执行
    document.title = count;
  })
  
  return (
    <div>
    	<h2>当前计数：{count}</h2>
      <button onClick={e => setCount(count+1)}>+1</button>
    </div>
  )
})

export default App;
~~~

