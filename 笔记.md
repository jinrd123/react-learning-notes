# jsx语法中让回调函数内部this正确访问类实例的方法

1. 类组件中，自定义函数内部this绑定组件实例的方式：

   1. bind修改类函数this：constructor中：`this.fn = fn.bind(this)`

   2. 使用class field特性：

      constructor之外定义的变量和方法和constructor中`this.`定义的变量和方法完全一样，只是constructor中`this.`的定义会对其进行覆盖；我们在constructor之外定义一个箭头函数，然后这个箭头函数里面的this就是类实例，我们绑定事件时直接使用这个箭头函数

      （这个原理暂时不是很懂）

   3. 绑定一个箭头函数，箭头函数的函数体内容就是调用类方法

      ~~~jsx
      <button onclick={() => this.fn() }>按钮</button>
      ~~~

      原理就是我们`{}`里面的是一个箭头函数，首先我们在jsx模板中是可以通过this访问class实例的，可以理解为jsx中的`{}`就是一个函数作用域，这个函数属于我们的类实例对象，就比如

      ~~~JS
      let obj = {
          name: "jrd",
          fn() {
              // jsx语法中的{}就类似于这里，obj就相当于组件类实例。我们在这里可以通过this访问obj，类似于jsx的{}中可以通过this访问类实例对象
          }
      }
      ~~~

      然后上面`onclick={() => this.fn() }`就类似于我们在`fn`中创建了一个箭头函数，这个箭头函数的父级作用域就是`fn`的函数作用域，`fn`属于`obj`，自然这个箭头函数中的this就是obj，类比到jsx中，说明this就是类实例，既然`this.fn()`中this是类实例，所以`fn`的调用方式就是被`this`调用，所以`fn`内部的this就都指向了`this`，也就是类实例

   

   不进行处理类方法中的this绑定不到类实例的原因：

   ~~~jsx
   <button onclick={this.fn}>按钮</button>
   ~~~

   这里相当于一个函数体赋值，我们只是把this.fn的函数体赋值给了一个内部变量，在触发onclick事件的时候，其实是对{}内的函数进行独立调用（直接调用），所以我们相当于直接执行`fn`，并没有执行`this.fn`，这就导致fn是没有`this`的，而是属于window的，所以fn函数体里的this都无法正常访问类实例的属性

# 函数传参

~~~jsx
class App extends React.Component {
    constructor() {
        super();
        this.state = {
            massage: "hello world"
        }
    }
    
    btnClick(event, name, age) {
        console.log("...")
    }
    
    reder() {
        const { message } = this.state;
        return (
        	<div>
                {/* 直接箭头函数接收event事件对象，然后函数体内给回调函数传参即可 */}
            	<button onclick={(event) => this.btnClick(event, "why", 18)}>按钮</button>
            </div>
        )
    }
}
~~~

# 创建脚手架项目

`npm install create-react-app -g`：全局安装react脚手架

`create-react-app demo`：创建名为demo的项目

`npm run start`：跑起来当前项目

# 组件通信

## 1.父传子props

父组件直接把数据在子组件标签中传给子组件；子组件的`contructor`函数接收一个`props`参数，然后调用`super(props)`。

子组件经过上述操作，就可以通过`this.props.父组件传来的数据`的方式获取到父组件传来的数据

父组件：

~~~jsx
<Child banner={banners}/>
~~~

子组件：

~~~jsx
export class AddCounter extends Component {
	constructor(props) {
        super(props)
    }
    
    render() {
        const { banners } = this.props
        return (
        	{/* 使用数据banners */}
        )
    }
}
~~~

## 2.子传父

父组件内部有操作组件内数据的方法，然后直接给子组件传递一个“包装函数”，即对自身方法的包装，函数体内是对自身方法的调用。**且这个函数是一个箭头函数。**

概况来说：父组件传给子组件的箭头函数就是为了调用真正修改数据的函数

子组件的某些事件触发子组件内的某个回调函数，回调函数的逻辑就是通过`this.props.父组件传来的方法`去调用父组件传递的箭头函数。

父组件：

~~~jsx
class App extends React.Component {
    constructor() {
        super();
        this.state = {
            counter: 0,
        }
    }

    changeCounter(counter) {
        this.setState({ counter: this.state.counter + counter })
    }	
    
    render() {
        const { counter } = this.state;
        return (
            <div>
                <h2>当前计数：{counter}</h2>
                <AddCounter addClick={(count) => this.changeCounter(count) }/>
            </div>
        )
    }
}

export default App;
~~~

子组件：

~~~jsx
export class AddCounter extends Component {
    addCount(count) {
        /*
        	因为addClick是父组件中传来的箭头函数，所以addClick函数体中的this一直都指向的是父组件实例，不会因为这里的调用方式而改变
        */
        this.props.addClick(count);
    }
    
    render(
    	<div>
    		<button onclick={() => this.addCount(1)}>+1</button>
        	<button onclick={() => this.addCount(2)}>+2</button>
        	<button onclick={() => this.addCount(5)}>+5</button>
    	</div>
    )
}
~~~

## 3.借助`React.createContext()`

1. 建立一个上下文对象

~~~js
import React from "react";

const ThemeContext = React.createContext();

export default ThemeContext
~~~

2. 通过上下文对象标签（ThemeContext上下文对应的上下文标签：<ThemeContext.Provider>）的的`value`属性给上下文标签内部的子组件传递数据

~~~jsx
<ThemeContext.Provider value={{color: "red", size: "30"}}>
    <Home></Home>
</ThemeContext.Provider>
~~~

3. 上下文标签内部的子组件（**后代组件**）需要绑定上下文（上面2相当于上下文提供了数据，但组件还没接收），然后才能使用上下文数据

Home组件的子组件HomeInfo组件：

~~~jsx
export class HomeInfo extends Component {
    reder() {
        return (
            {/* 组件内部直接使用上下文标签的value属性提供的数据 */}
        	<div>{this.context.red}</div>
        )
    }
}

//组件暴露前绑定上下文
HomeInfo.contextType = ThemeContext

export default HomeInfo
~~~

函数式组件中获取上下文提供的数据：

我们在想使用数据的地方使用上下文对应的<ThemeContext.Consumer>标签，标签内部的{}内是一个函数，这个函数接收的第一个参数就是<ThemeContext.Provider>的value属性，通过value属性自然就可以拿到数据了

~~~jsx
import ThemeContext from "..."

function HomeBanner() {
    return <div>
    	<ThemeContext.Consumer>
        	{
                value => {
                    return <h2>{ value.color }</h2>
                }
            }
        </ThemeContext.Consumer>
    </div>
}
~~~

当然<ThemeContext.Consumer>不只是在函数组件中使用，如果一个自定义组件在很多个嵌套的上下文标签内部，绑定上下文对象只能绑定一个，所以他如果想获得多个上下文的数据，可以使用<ThemeContext.Consumer>，与绑定的那个上下文`this.context`不冲突。

# 组件的生命周期

常用：

* constructor
* render
* componentDidMount
* componentDidUpdate
* componentWillUnmount

# 类型验证

* propTypes
* defaultProps

# react实现插槽效果

## this.props.children

父组件中直接往子组件的中间放dom元素，放在自定义组件中间的dom元素会按顺序出现在子组件的`props.children`数组中，这里所说的dom是指jsx中的dom，自然子组件中通过`this.props.children[index]`访问到的自然是jsx语法下的dom元素，这个元素直接可以在子组件的jsx模板中使用。

父组件：

~~~jsx
render() {
    return (
        <div>
            <NavBar>
                <button>按钮</button>
                <h2>标题</h2>
                <i>斜体文字</i>
            </NavBar>
        </div>
	)
}
~~~

子组件：

~~~jsx
render() {
    const { children } = this.props;
    return (
        <div>
            <div className="left">{children[0]}</div>
            <div className="center">{children[1]}</div>
            <div className="right">{children[2]}</div>
        </div>
    )
}
~~~

plus：如果父组件中，子组件的中间只传递了一个dom标签，那么子组件内部`this.props.children`就是这个dom，而不是一个数组。

## this.props（推荐）

在父组件中我们直接给子组件标签传递属性，但是我们传递的属性值就是jsx的dom元素，所以我们在子组件中通过`this.props`解构赋值就可以拿到父组件传来的dom元素，而不用借助`children`属性

子组件：

~~~jsx
render() {
    const { leftSlot, centerSlot, rightSlot } = this.props;
    return (
        <div>
            <div className="left">{leftSlot}</div>
            <div className="center">{centerSlot}</div>
            <div className="right">{rightSlot}</div>
        </div>
    )
}
~~~

父组件：

~~~jsx
render() {
    return (
        <div>
            <NavBar
            	leftSlot={<button>按钮</button>}
                centerSlot={<h2>标题</h2>}
                rightSlot={<i>斜体文字</i>}
            />
        </div>
	)
}
~~~

## 作用域插槽

概念：我们父组件决定子组件使用什么dom结构（标签），数据仍然是子组件自身的。

实现：父组件直接传给子组件一个返回dom结构的函数，子组件自己去调用这个函数并传入自身的数据来生成最终的jsxDOM即可

父组件：

~~~jsx
render() {
    return (
        <div>
            <NavBar
            	itemType={(item) => <button>{item}</button>}
            />
        </div>
	)
}
~~~

子组件：

~~~jsx
render() {
    const { itemType } = this.props;
    return (
        <div>
            {itemType(子组件本身的数据)}
        </div>
    )
}
~~~





# CSS方案

## css modules

css modules不是React特有的方案，而是打包工具提供的方案：比如webpack环境下，配置webpack.config.js的modules:true

React脚手架已经内置了css modules的配置，所以我们可以直接使用这种css方案：

1. .css/.less/.scss等样式文件都需要改成.module.css/.module.less/.module.scss
2. 在组件中引入.module.css样式模块：`import Style1 from "./profile.module.css"`
3. 在jsx的模版中使用：`<div calssName={Stype1.xxxClass}></div>`

`profile/Profile.jsx`:

~~~jsx
import { memo } from 'react';
import profileStyle from "./Profile.module.css";

const Profile = memo(function() {

    return (
      	// className中使用多个css类名——用()包裹；使用单个css类不需要()
        <div className={(profileStyle.section, profileStyle.anotherSection)}>
        	hello
        </div>
    )
})

export default Profile;
~~~

`profile/Profile.module.css`：

~~~css
.section {
    border: 1px solid skyblue;
}

.anotherSection {
    background-color: aqua;
}
~~~

Css modules的css方案可以解决react组件之间样式冲突问题：原理就是浏览器中真正生成的css类名其实为：`文件名_css类名_一段随机哈希字符串`。

缺点：css文件中编写类名时不能使用`-连接符，因为js中不识别，只能用单个字符串（或者驼峰式）命名；不方便动态修改某些样式，需要借助内联样式实现

## css in js（终极方案）

借助styled-components库

`npm install styled-components`

vscode插件：vscode-styled-components（css代码语法高亮）



---

Plus标签模版字符串的使用：

~~~typescript
function foo(...args) {
  console.log(args);
}

foo("why", 18, 1.88); // 普通调用
foo`my name is ${name}, age is ${age}` // 标签模版字符串调用函数： 函数`paramsStr`
~~~

标签模版字符串的输出：

~~~js
[
  ['my name is', 'age is', ''],
  "why",
  18
]
~~~

也就是说，如果用``给某个函数传参的话，会把模版字符串的内容以${}进行分割，第一个参数是一个数组，数组里的项就是${}分割之后的子字符串，剩下的第二第三...等参数就依次是${}进行变量替换后的结果

---



styled-components基本使用：

`style.js`：

~~~js
import styled from "styled-components";

export const AppWrapper = styled.div`
	.section {
		border: 1px solid red;
		
		.title {
			font-size: 30px;
			
			&:hover {
				background-color: purple;
			}
		}
	}
	
	.footer {
		border: 1px solid orange;
	}
`
~~~

原理上来讲就是styled-components提供的styled对象里面有很多方法，div就是其中的一个方法，这个方法最终返回一个组件（div函数根据``接收的参数给它的子类添加样式，具体咋实现的那就是styled-components完成的事情了），我们就是拿着这个组件去用就行了

`App.jsx`：

~~~jsx
import React, { PureComponent } from 'react';
import { AppWrapper } from "./style";

export class App extends PureComponent {
  render() {
    return (
    	<AppWrapper>
      	<div className='section'>
        	<h2 className='title'>我是标题</h2>
        </div>
        <div className='footer'>
        	<p>hhh</p>
        </div>
      </AppWrapper>
    )
  }
}

export default App
~~~

<AppWrapper>相当于我们用styled.div方法创建出来的div标签，这个组件与div的不同之处就在于这个组件会给它的子元素添加样式。

# React性能优化

我们在`extends Component`的类组件中，只要是调用`this.setState`就会触发`render`函数的执行，包括里面所有的自组件默认情况下都会重新渲染，为了减少无效render（数据没变）的频率，我们需要在`shouldComponentUpdate(nextProps, newState)`生命周期中进行逻辑判断是否state或者props发生改变，对应返回true或false（是否渲染）。为了避免这种繁琐的逻辑判断：

只需要让类组件继承PureComponent：组件会自动进行判断state或者props是否发生改变，改变则调用render

我们希望函数组件也能根据props是否改变来决定是否重新渲染，就需要用到react提供的memo方法：

~~~js
import { memo } from "react";

const Profile = memo(函数组件函数); // memo接收原来的函数组件，返回一个组件，这个组件就有自动判断是否render的功能

export default Profile;
~~~



# React Hooks

作用：在不使用类组件的前提下，让函数组件中使用state以及react生命周期等特性

## useState

函数组件结合hook（useState）实现计数器组件：

~~~jsx
import React, { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);
  
  return (
  	<div>
    	<h2>当前计数：{count}</h2>
      <button onClick={e => setCount(count + 1)}>+1</button>
      <button onClick={e => setCount(count - 1)}>-1</button>
    </div>
  )
}
~~~

只能在函数的最外层调用hook（不能放在if中等子作用域）

useState的实现原理：usestate会在一个函数组件外部（反正不随函数组件的执行完毕而销毁）定义一个state变量，这其实就等价于class组件中的this.state，实现函数组件state状态保留的效果。

（useState这种函数就是一个hook）

## useEffect

对于函数组件来说，把类似于网络请求、DOM操作（比如如下的修改document.title）、事件监听等逻辑放到函数体的最上层是不合理的，这些事情都是组件渲染带来的副作用，这也就是useEffect的意思：把渲染组件伴随的副作用逻辑放到useEffect的回调函数中

实现计数器数值改变时修改document.title：

~~~jsx
import React, {memo} from "react";
import { useState, useEffect } from "react";

const App = memo(() => {
  const [count, setCount] = useState(200);
  
  useEffect(() => { // 当前回调函数会在组件被渲染完成后自动执行
    document.title = count;
  })
  
  return (
    <div>
    	<h2>当前计数：{count}</h2>
      <button onClick={e => setCount(count+1)}>+1</button>
    </div>
  )
})

export default App;
~~~

在类组件的编写中，某些副作用代码（比如取消订阅之类的），我们需要在componentWillUnmount中进行清除，对应函数组件，我们利用useEffect的回调函数的返回值来进行模拟：

useEffect回调函数的返回值是一个函数，这个函数在每次组件更新或以及卸载的时候执行：

~~~jsx
useEffect(() => {
  console.log("副作用逻辑")
  return () => {
    console.log("清除副作用的逻辑——副作用逻辑执行之前会先执行上一次useEffect返回的回调函数")
  }
})
~~~

**一个函数式组件中，可以存在多个useEffect**，这样就可以把相关的副作用逻辑放在一起，还有好处就是方便抽取一个useEffect为一个自定义hook（后面学习）

### 控制回调的执行

useEffect的第二个参数（可选参数），如果省略就相当于这个useEffect的回调在每次组件渲染时都会执行；显式指定第二个参数为一个数组，里面存放变量，表示只有数组中的变量发生改变时才会执行这个useEffect回调；如果第二个参数为空数组，则代表这个回调函数的执行与任何变量都不相关，所以只有在函数组件第一次渲染时执行，其返回的回调函数也只在函数组件卸载时执行一次。

~~~jsx
import React, {memo} from "react";
import { useState, useEffect } from "react";

const App = memo(() => {
  const [count, setCount] = useState(200);
  
  useEffect(() => {
    document.title = count;
  }, [count]) // 只有count改变时才会执行
  
  useEffect(() => {
    console.log("网络请求逻辑");
  }, []) // 只有组件首次渲染时执行
  
  useEffect(() => {
    console.log("消息订阅");
    return () => {
      console.log("取消订阅");
    }
  }, []) // 组件首次渲染时执行消息订阅相关逻辑，组件卸载时执行返回的函数的逻辑
  
  return (
    <div>
    	<h2>当前计数：{count}</h2>
      <button onClick={e => setCount(count+1)}>+1</button>
    </div>
  )
})

export default App;
~~~

所以说useEffect并不是单纯的可以模拟class组件中的生命周期，而是比原来的生命周期更加强大（可以灵活的逻辑抽离以及控制执行时机）

**state hook和effect hook两个hook已经涵盖了业务开发百分之九十的场景了，下面的hook是一些特殊场景以及性能优化相关的hook**

## useContext

组件内：

~~~jsx
import React, { memo, useContext } from "react";
import { UserContext, ThemeContext } from "./context";

const App = memo(() => {
	const user = useContext(UserContext);
  const theme = useContext(ThemeContext);
  
  return (
    <div>
			<h2>User:{user.name}--{user.level}</h2>
      {/* 给标签添加动态样式style={},然后{}内部又是一个对象，此对象的键值对为css样式 */}
      <h2 style={{color: theme.color, fontSize: theme.size}}>Theme</h2> 
    </div>
  )
})

export default App;
~~~

`./context.js`：

~~~js
import { createContext } from "react";

const UserContext = createContext({name: "jrd", level: "下等马"});
const ThemeContext = createContext({color: "red", size: "200px"});

export {
    UserContext,
    ThemeContext,
}
~~~

Plus:当组件中context数据发生变化时会触发函数组件的重新渲染

## useRef

为了避免在react框架中使用`document.querySelector`等原生方法操作dom，可以使用useRef：

函数组件中先使用useRef创建一个变量`A`，然后给jsx模版中想获得的dom元素绑定属性：`ref={A}`，这样就完成了绑定，我们就可以在js逻辑中通过`A.current`拿到dom了。

`UseRef.jsx`：

~~~jsx
import { memo, useRef } from 'react'

const UseRef = memo(function UseRef() {
    const containerRef = useRef();
    function showContainerDom() {
        console.log(containerRef.current);
    }
    return (
        <div ref={containerRef}>
            hello
            <button onClick={showContainerDom}>点击显示绑定的dom</button>
        </div>
    )
})

export default UseRef;
~~~

useRef创建的变量是脱离函数作用域的，也就是说不随函数重复执行而重复创建：

**使用useRef解决闭包陷阱——好像需要useCallback相关的知识，留坑：定位react全家桶09p13**

## useCallback

useCallback是用来做性能优化的，useCallback接收一个函数作为参数并返回（useCallback返回的此函数是有“记忆”的），与useEffect相似，第二个数组参数决定此函数重新声明依赖哪些变量：

* 空数组就是啥也不依赖，整个函数就声明创建一次
* 省略此参数就是啥都依赖，函数组件每次重新渲染（执行）都会同步创建一次此函数

使用场景：

​	**当需要将一个函数传递给子组件时，最好使用useCallback进行优化——防止子组件重复渲染**，将优化之后的函数传递给子组件（如果直接传递给子组件，这个函数是作为子组件的props属性的，如果父组件每次重新渲染都重新声明这个函数，就会导致子组件的props改变，导致子组件进行无谓的渲染）：

父组件：

~~~jsx
const App = memo(function() {
  const [count, setCount] = useState(0);
  const increment = useCallback(function() {
    setCount(count+1);
  },[count]); // 这样就代表只有count改变时才会重新定义一遍increment函数；如果省略，就代表App组件每次渲染都重新定义increment从而导致渲染Child组件——不合适；如果这里写一个空数组，会出现“闭包陷阱问题”
  return (
  	<div>
    	<h2>计数</h2>
      <button onClick={increment}>+1</button>
      <Child increment={increment}/>
    </div>
  )
})
~~~

子组件：

~~~jsx
const Child = memo(function(props) {
  const { increment } = props;
  return (
    // 此组件非常庞大,也有非常多的子组件，不适合频繁的重复渲染
  	<button onClick={increment}>+1</button>
  )
})
~~~

### plus——闭包陷阱问题：

~~~jsx
const App = memo(function() {
  const [count, setCount] = useState(0);
  const increment = useCallback(function() {
    setCount(count+1);  
  },[]); // 这里我们写一个空数组，希望这个函数永远不重新定义——造成闭包陷阱：useCallback创建increment函数时接收到的第一个函数参数是可以访问这个函数组件里的变量的，就比如这里setCount(count+1),我们就拿到了count变量，这个count是属于当前这个App组件的，也就形成了一个闭包（count的值是创建increment函数这一时刻的一个不会再改变的量）
  // 对于increment这个函数来说，他里面的count就一直是当下这个App组件状态中的count
  // 所以当我们点击+1按钮时，第一次会成功将父组件中的计数加一，但是再次点击就没反应了，因为increment里面setCount的参数count+1从未改变过
  return (
  	<div>
    	<h2>计数</h2>
      <button onClick={increment}>+1</button>
      <Child increment={increment}/>
    </div>
  )
})
~~~

问题抽象：

~~~js
function foo(name) { // foo相当于函数组件， name相当于组件中的状态变量
  return function bar() { // bar相当于我们用useCallback返回的函数
    console.log(name); // 这里的name在创建bar时就已经确定了，以后都不会改变了，即使foo函数重新执行，这里的name都是原本的那个foo函数的name（原本的foo函数里的bar函数称为一个闭包，封锁了foo作用域）
  };
}

const bar1 = foo("jrd"); // 调用bar1函数只会输出jrd，也就相当于setCount时其参数一直都是那一个值
~~~

#### 结论：

使用useCallback时，如果有修改状态的逻辑，记得在第二个数组参数中添加被修改的状态变量，防止闭包陷阱

### useCallback结合useRef进一步优化

useRef：在组件多次渲染时返回的是同一个值（对象），这个对象有一个current属性，可以用来存放数据：

父组件：

~~~jsx
const App = memo(function() {
  const [count, setCount] = useState(0);
  const countRef = useRef(); // 创建一个useRef对象（始终同一个）
  countRef.current = count;
  const increment = useCallback(function() {
    setCount(countRef.current+1);
  },[]); // 此时increment函数不依赖任何变量而重新创建，我们通过countRef对象，相当于通过这层引用关系，总能给count设置正确的值（闭包陷阱的核心原因其实就是因为闭包函数拿到的状态变量是一个普通数据类型）
  return (
  	<div>
    	<h2>计数</h2>
      <button onClick={increment}>+1</button>
      <Child increment={increment}/>
    </div>
  )
})
~~~

